我看到问题了。现在私聊消息能够正确显示在私聊窗口了，但是出现了重复消息的问题。这是因为：

1. **本地回显**：当你发送消息时，控制器会立即在本地显示（`self.message_sent.emit(private_message_vo)`）
2. **服务器回传**：服务器收到私聊消息后，会回传给发送者一份（在 `message_manager.py` 中的 `send_private_message` 方法中）
3. **双重显示**：这两次显示都触发了私聊窗口的消息添加，导致了重复

让我修复这个问题：

## 1. 首先修改 `message_manager.py`，不要将私聊消息回传给发送者

```python
async def send_private_message(self, sender_username: str, receiver_username: str, content: str, 
                             content_type: str = 'text', timestamp=None, file_data: str = None, 
                             filename: str = None, file_size: int = 0) -> bool:
    """发送私聊消息"""
    if timestamp is None:
        timestamp = time.time()

    # 获取发送者和接收者信息
    async with PgHelper.get_async_session(self.db_engine) as session:
        sender = await user_crud.get_by_username(session, sender_username)
        receiver = await user_crud.get_by_username(session, receiver_username)
        
        if not sender or not receiver:
            log.error(f"发送私聊消息失败: 用户不存在 - {sender_username} -> {receiver_username}")
            return False

        # 获取或创建私聊会话
        conversation = await self.private_conversation_crud.get_by_users(
            session, str(sender.user_id), str(receiver.user_id)
        )
        if not conversation:
            # 创建新的私聊会话
            conversation = await self.private_conversation_crud.create(
                session,
                user1_id=min(str(sender.user_id), str(receiver.user_id)),
                user2_id=max(str(sender.user_id), str(receiver.user_id))
            )

        # 构造私聊消息 - 确保type为'private'
        private_message = {
            'type': 'private',
            'username': sender_username,
            'receiver': receiver_username,
            'content': content,
            'content_type': content_type,
            'timestamp': time.strftime('%H:%M:%S', time.localtime(timestamp)),
            'conversation_id': str(conversation.conversation_id)  # 添加会话ID
        }

        # 如果是文件类型，添加文件相关信息
        if content_type in ['image', 'video', 'file', 'audio'] and filename:
            private_message.update({
                'filename': filename,
                'data': file_data,
                'size': file_size
            })

        # 保存私聊消息到数据库
        message_data = {
            'conversation_id': str(conversation.conversation_id),
            'sender_id': str(sender.user_id),
            'receiver_id': str(receiver.user_id),
            'content_type': content_type,
            'content': content,
            'metadata_': {'timestamp': timestamp}
        }

        # 如果是文件类型，添加文件信息
        if content_type in ['image', 'video', 'file', 'audio'] and filename:
            message_data.update({
                'file_name': filename,
                'file_size': int(file_size) if file_size else 0
            })

        saved_message = await self.private_message_crud.create(session, **message_data)

        # 更新会话的最后消息信息
        await self.private_conversation_crud.update_last_message(
            session, str(conversation.conversation_id), str(saved_message.message_id)
        )

    # 检查接收者是否在线
    if self.connection_manager.is_client_connected(receiver_username):
        # 获取接收者的socket连接
        receiver_client = self.connection_manager.get_client(receiver_username)
        if receiver_client:
            try:
                # 发送私聊消息给接收者
                receiver_client.socket.send(json.dumps(private_message).encode('utf-8'))
                log.info(f"私聊消息已发送给接收者: {sender_username} -> {receiver_username}")
                
                # 重要：不再回传给发送者，因为发送者已经有本地回显了
                # 发送者可以通过发送成功后立即显示消息，不需要服务器回传
                
                return True
            except Exception as e:
                log.error(f"发送私聊消息给 {receiver_username} 失败: {e}")
                return False
        else:
            log.error(f"无法找到接收者 {receiver_username} 的客户端信息")
            return False
    else:
        log.info(f"接收者 {receiver_username} 不在线，消息已保存到数据库")
        return True  # 消息已保存到数据库，返回True表示处理成功
```

## 2. 修改 `chat_controller.py`，在发送私聊消息时更清晰地处理本地回显

```python
def send_private_message(self, receiver: str, content: str, conversation_id: str = "") -> bool:
    """发送私聊消息"""
    try:
        if not self.network_manager.is_connected():
            self.system_message.emit("未连接到服务器")
            return False
        
        if not content.strip():
            self.system_message.emit("私聊消息内容不能为空")
            return False
        
        if not receiver:
            self.system_message.emit("请选择接收者")
            return False
        
        # 构造私聊消息数据
        data = {
            'type': 'private',
            'username': self.current_user,
            'receiver': receiver,
            'content': content,
            'content_type': 'text',
            'timestamp': datetime.now().timestamp()
        }
        
        # 如果有会话ID，添加到数据中
        if conversation_id:
            data['conversation_id'] = conversation_id
        
        # 创建私聊消息VO对象用于本地回显
        from client.models.vo import PrivateMessageVO
        private_message_vo = PrivateMessageVO(
            message_id="",
            user_id="",
            username=self.current_user,
            receiver_name=receiver,
            content_type="text",
            content=content,
            conversation_id=conversation_id,
            created_at=datetime.now()
        )
        
        # 先发送消息到服务器
        self.network_manager.send_data(data)
        log.info(f"私聊消息已发送: {self.current_user} -> {receiver}, 内容: {content[:50]}...")
        
        # 然后立即在本地显示（回显）
        self.message_sent.emit(private_message_vo)
        
        return True
    except Exception as e:
        log.error(f"发送私聊消息时发生错误: {e}")
        import traceback
        traceback.print_exc()
        return False
```

## 3. 修改 `chat_view.py`，在处理接收到的私聊消息时过滤掉自己发送的消息

```python
def on_message_received(self, message_obj):
    """处理接收到的消息"""
    log.debug(f"视图接收到消息对象: {message_obj}")
    
    try:
        # 检查是否是消息列表（历史消息）
        if isinstance(message_obj, list):
            log.debug(f"视图接收到历史消息列表，共 {len(message_obj)} 条消息")
            
            # 检查是否是私聊历史消息
            is_private_history = False
            if message_obj and (hasattr(message_obj[0], 'receiver_name') or hasattr(message_obj[0], 'receiver')):
                is_private_history = True
            
            # 如果是私聊历史消息，需要转发到对应的私聊窗口
            if is_private_history and message_obj:
                # 获取第一条消息的信息来确定是哪个私聊会话
                first_msg = message_obj[0]
                
                # 确定私聊窗口的键名
                if hasattr(first_msg, 'username') and first_msg.username == self.username:
                    # 自己发送的消息，私聊窗口键名应该是 receiver_self
                    target_user = getattr(first_msg, 'receiver_name', '') or getattr(first_msg, 'receiver', '')
                    private_window_key = f"{target_user}_{self.username}"
                else:
                    # 接收到的消息，私聊窗口键名应该是 sender_self
                    target_user = first_msg.username
                    private_window_key = f"{target_user}_{self.username}"
                
                # 查找对应的私聊窗口
                if private_window_key in self.controller.private_chat_windows:
                    private_chat_window = self.controller.private_chat_windows[private_window_key]
                    private_chat_window.load_history_messages(message_obj)
                else:
                    # 没有对应的私聊窗口，创建并显示
                    self._create_and_show_private_chat_window_for_history(target_user, message_obj)
                return  # 私聊历史消息处理完成
            
            # 普通历史消息处理
            for msg in message_obj:
                if isinstance(msg, dict):
                    self.message_area.insert_message_at_top(msg)
                
                # 更新最旧的消息ID
                if hasattr(msg, 'message_id') and msg.message_id:
                    self.message_area._oldest_message_id = msg.message_id
            
            # 所有历史消息插入完成后，重置加载状态
            self.message_area._is_loading = False
            # 重新启用加载按钮
            self.message_area.load_history_btn.setEnabled(True)
            return
            
        # 检查消息对象类型
        if hasattr(message_obj, 'content_type'):
            # 如果是VO对象
            content_type = message_obj.content_type
            
            # 检查是否为私聊消息
            is_private = (hasattr(message_obj, 'receiver_name') or 
                         hasattr(message_obj, 'receiver') or 
                         content_type == 'private')
            
            if is_private:
                # 私聊消息
                sender = message_obj.username
                receiver = getattr(message_obj, 'receiver_name', '') or getattr(message_obj, 'receiver', '')
                
                if not receiver:
                    log.warning(f"私聊消息缺少接收者信息: {message_obj}")
                    return
                
                # 检查消息方向：如果是自己发送的消息，不处理（因为已有本地回显）
                if sender == self.username:
                    log.debug(f"忽略自己发送的私聊消息: {sender} -> {receiver}")
                    return
                
                # 接收到的私聊消息
                target_user = sender
                private_window_key = f"{target_user}_{self.username}"
                
                if private_window_key in self.controller.private_chat_windows:
                    # 发送到对应的私聊窗口
                    private_chat_window = self.controller.private_chat_windows[private_window_key]
                    private_chat_window.add_private_message(message_obj)
                    # 确保私聊窗口显示
                    private_chat_window.bring_to_front()
                else:
                    # 没有对应的私聊窗口，自动创建并显示
                    self._create_and_show_private_chat_window(target_user, message_obj)
                return  # 私聊消息处理完成
            elif content_type == "system":
                # 处理系统消息
                content = getattr(message_obj, 'content', '')
                self.add_system_message(content)
            else:
                # 普通公共消息
                self.message_area.add_message(message_obj)
                # 只有当用户已经在底部时才自动滚动到底部
                if self.message_area.should_auto_scroll():
                    QTimer.singleShot(100, self.message_area.scroll_to_bottom)
        elif isinstance(message_obj, dict):
            # 如果是字典格式
            if message_obj.get('receiver') or message_obj.get('receiver_name'):
                # 私聊消息
                sender = message_obj.get('username', '')
                receiver = message_obj.get('receiver', '') or message_obj.get('receiver_name', '')
                
                if not receiver:
                    log.warning(f"私聊消息缺少接收者信息: {message_obj}")
                    return
                
                # 检查消息方向：如果是自己发送的消息，不处理（因为已有本地回显）
                if sender == self.username:
                    log.debug(f"忽略自己发送的私聊消息: {sender} -> {receiver}")
                    return
                
                # 接收到的私聊消息
                target_user = sender
                private_window_key = f"{target_user}_{self.username}"
                
                if private_window_key in self.controller.private_chat_windows:
                    # 发送到对应的私聊窗口
                    from client.models.vo import PrivateMessageVO
                    private_message_vo = PrivateMessageVO.from_dict(message_obj)
                    private_chat_window = self.controller.private_chat_windows[private_window_key]
                    private_chat_window.add_private_message(private_message_vo)
                    # 确保私聊窗口显示
                    private_chat_window.bring_to_front()
                else:
                    # 没有对应的私聊窗口，自动创建并显示
                    self._create_and_show_private_chat_window(target_user, message_obj)
                return  # 私聊消息处理完成
            elif message_obj.get('content_type') == 'system':
                self.add_system_message(message_obj.get('content', ''))
            else:
                self.message_area.add_message(message_obj)
                # 只有当用户已经在底部时才自动滚动到底部
                if self.message_area.should_auto_scroll():
                    QTimer.singleShot(100, self.message_area.scroll_to_bottom)
        else:
            log.error(f"未知的消息格式: {type(message_obj)}")
            self.add_system_message(f"消息格式错误: {type(message_obj)}")
            
    except Exception as e:
        log.error(f"处理消息时出错: {e}")
        import traceback
        traceback.print_exc()
        self.add_system_message("消息处理错误")
        # 发生异常时也要重置加载状态
        self.message_area._is_loading = False
        # 发生异常时也要重新启用加载按钮
        if hasattr(self.message_area, '_is_loading'):
            self.message_area.load_history_btn.setEnabled(True)
```

## 4. 修改 `network_manager.py`，在客户端网络层也过滤掉自己发送的私聊消息

```python
def handle_message(self, data: dict):
    """处理接收到的消息"""
    log.debug(f"网络层接收到原始数据: {data}")
    msg_type = data.get('type')
    
    # 私聊消息处理应该放在最前面
    if msg_type == 'private':
        # 获取消息发送者
        username = data.get('username', '')
        
        # 如果是自己发送的消息，忽略它（因为已有本地回显）
        if username == self.username:
            log.debug(f"网络层忽略自己发送的私聊消息: {username}")
            return
        
        # 处理接收到的私聊消息
        receiver = data.get('receiver', '')
        content = data.get('content', '')
        content_type = data.get('content_type', 'text')
        timestamp = data.get('timestamp', time.time())
        
        # 确保timestamp是数值类型
        if isinstance(timestamp, str):
            try:
                timestamp = float(timestamp)
            except ValueError:
                timestamp = time.time()
        
        # 创建私聊消息VO对象
        from client.models.vo import PrivateMessageVO
        private_message_vo = PrivateMessageVO(
            message_id=data.get('message_id', ''),
            user_id=data.get('user_id', ''),
            username=username,
            receiver_name=receiver,
            content_type=content_type,
            content=content,
            conversation_id=data.get('conversation_id', ''),
            created_at=datetime.fromtimestamp(timestamp) if timestamp else None
        )
        
        # 如果是文件类型消息，需要处理文件数据
        if content_type in ['image', 'video', 'audio', 'file']:
            filename = data.get('filename', '')
            file_url = data.get('file_url', '')
            file_size = data.get('size', 0)
            if isinstance(file_size, str):
                try:
                    file_size = int(file_size)
                except ValueError:
                    file_size = 0
            
            # 创建文件VO对象
            file_vo = FileVO(
                file_id=data.get('file_id', ''),
                file_name=filename,
                file_url=file_url,
                file_type=content_type,
                file_size=file_size,
                created_at=datetime.fromtimestamp(timestamp) if timestamp else None
            )
            
            # 如果是服务器转发的消息且有file_data，则保存文件
            file_data = data.get('data', '')
            if file_data:
                # 保存文件
                file_path = self.save_file(filename, file_data)
                if file_path:
                    # 更新file_vo的file_url为本地保存路径
                    file_vo.file_url = file_path
                    # 发送文件接收信号
                    self.file_received.emit(filename, file_path)
            
            private_message_vo.file_vo = file_vo
        
        log.info(f"网络层处理接收到的私聊消息: {username} -> {receiver}, 内容: {content[:50]}...")
        # 发送私聊消息到视图层
        self.message_received.emit(private_message_vo)
        return  # 私聊消息处理完成
        
    # ... 其他消息类型的处理保持不变
```

## 关键修改点：

1. **服务器不再回传**：在 `message_manager.py` 中，服务器只将私聊消息发送给接收者，不再回传给发送者
2. **本地回显**：在 `chat_controller.py` 中，发送消息后立即在本地显示（回显）
3. **双重过滤**：
   - 在 `network_manager.py` 中过滤掉自己发送的私聊消息
   - 在 `chat_view.py` 中也过滤掉自己发送的私聊消息
4. **清晰的消息流向**：
   - 发送方：本地回显显示一次
   - 接收方：收到服务器转发显示一次

这样修改后，私聊消息就不会重复显示了。每条消息应该只在：
1. 发送方的私聊窗口显示一次（本地回显）
2. 接收方的私聊窗口显示一次（服务器转发）

如果问题仍然存在，请检查私聊窗口的 `add_private_message` 方法是否被重复调用。