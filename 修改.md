根据你提供的日志和代码，我发现了私聊历史消息加载的问题。从服务端日志可以看到，私聊历史消息查询返回的是空列表 `[]`，这说明数据库中没有找到对应的私聊消息。原因有以下几点：

## 主要问题分析：

1. **会话ID不匹配**：客户端创建的私聊窗口使用随机生成的会话ID，而服务端存储消息时使用的是不同的会话ID
2. **数据库查询逻辑问题**：服务端使用错误的会话ID查询历史消息

## 修复方案：

### 1. 首先修改 `message_manager.py` 中的 `send_private_message` 方法

在发送私聊消息时，需要将正确的 `conversation_id` 包含在发送给客户端的消息中：

```python
async def send_private_message(self, sender_username: str, receiver_username: str, content: str, 
                               content_type: str = 'text', timestamp=None, file_data: str = None, 
                               filename: str = None, file_size: int = 0) -> bool:
    # ... 前面的代码保持不变 ...
    
    # 构造私聊消息
    private_message = {
        'type': 'private',
        'message_type': 'private',
        'username': sender_username,
        'receiver': receiver_username,
        'content': content,
        'content_type': content_type,
        'timestamp': time.strftime('%H:%M:%S', time.localtime(timestamp)),
        'conversation_id': str(conversation.conversation_id)  # 添加这一行
    }
    
    # ... 后续代码保持不变 ...
```

### 2. 修改 `chat_view.py` 中的 `on_message_received` 方法

确保正确处理私聊消息中的会话ID：

```python
def on_message_received(self, message_obj):
    """处理接收到的消息"""
    log.debug(f"视图接收到消息对象: {message_obj}")
    
    try:
        # 检查是否是消息列表（历史消息）
        if isinstance(message_obj, list):
            log.debug(f"视图接收到历史消息列表，共 {len(message_obj)} 条消息")
            
            # 检查是否是私聊历史消息（列表中的第一条消息如果有receiver字段）
            is_private_history = False
            if message_obj and hasattr(message_obj[0], 'receiver_name'):
                is_private_history = True
            
            # 如果是私聊历史消息，需要转发到对应的私聊窗口
            if is_private_history and message_obj:
                # 获取第一条消息的发送者来确定是哪个私聊会话
                first_msg = message_obj[0]
                if hasattr(first_msg, 'receiver_name'):
                    # 判断消息方向：是发送给别人的还是接收到的
                    sender = first_msg.username
                    receiver = first_msg.receiver_name
                    
                    # 确定私聊窗口的键名
                    if sender == self.username:
                        # 自己发送的消息，私聊窗口键名应该是 receiver_self
                        target_user = receiver
                        private_window_key = f"{target_user}_{self.username}"
                    else:
                        # 接收到的消息，私聊窗口键名应该是 sender_self
                        target_user = sender
                        private_window_key = f"{target_user}_{self.username}"
                    
                    # 查找对应的私聊窗口
                    if private_window_key in self.controller.private_chat_windows:
                        private_chat_window = self.controller.private_chat_windows[private_window_key]
                        private_chat_window.load_history_messages(message_obj)
                    else:
                        # 没有对应的私聊窗口，创建并显示
                        self._create_and_show_private_chat_window_for_history(target_user, message_obj)
                    return  # 私聊历史消息处理完成
            # ... 其他处理保持不变 ...
            
        # 检查消息对象类型
        if hasattr(message_obj, 'content_type'):
            # 如果是VO对象
            content_type = message_obj.content_type
            
            if hasattr(message_obj, 'receiver_name') or hasattr(message_obj, 'receiver'):
                # 私聊消息，需要转发到相应的私聊窗口
                sender = message_obj.username
                receiver = getattr(message_obj, 'receiver_name', '') or getattr(message_obj, 'receiver', '')
                
                # ... 省略中间代码 ...
                
                if private_window_key in self.controller.private_chat_windows:
                    # 发送到对应的私聊窗口
                    private_chat_window = self.controller.private_chat_windows[private_window_key]
                    # 如果消息中包含会话ID，更新窗口的会话ID
                    if hasattr(message_obj, 'conversation_id') and message_obj.conversation_id:
                        from client.models.vo import ConversationVO
                        updated_conversation = ConversationVO(
                            conversation_id=message_obj.conversation_id,
                            user1_name=self.username,
                            user2_name=target_user,
                            user1_id="",
                            user2_id=""
                        )
                        private_chat_window.update_conversation(updated_conversation)
                    private_chat_window.add_private_message(message_obj)
                    # 确保私聊窗口显示
                    private_chat_window.bring_to_front()
                else:
                    # 没有对应的私聊窗口，自动创建并显示
                    self._create_and_show_private_chat_window(target_user, message_obj)
        elif isinstance(message_obj, dict):
            # 如果是字典格式
            if message_obj.get('receiver') or message_obj.get('receiver_name'):
                # 私聊消息
                sender = message_obj.get('username', '')
                receiver = message_obj.get('receiver', '') or message_obj.get('receiver_name', '')
                
                # ... 省略中间代码 ...
                
                if private_window_key in self.controller.private_chat_windows:
                    # 发送到对应的私聊窗口
                    from client.models.vo import PrivateMessageVO, ConversationVO
                    private_message_vo = PrivateMessageVO.from_dict(message_obj)
                    private_chat_window = self.controller.private_chat_windows[private_window_key]
                    # 如果消息中包含会话ID，更新窗口的会话ID
                    if 'conversation_id' in message_obj and message_obj['conversation_id']:
                        updated_conversation = ConversationVO(
                            conversation_id=message_obj['conversation_id'],
                            user1_name=self.username,
                            user2_name=target_user,
                            user1_id="",
                            user2_id=""
                        )
                        private_chat_window.update_conversation(updated_conversation)
                    private_chat_window.add_private_message(private_message_vo)
                    # 确保私聊窗口显示
                    private_chat_window.bring_to_front()
                else:
                    # 没有对应的私聊窗口，自动创建并显示
                    self._create_and_show_private_chat_window(target_user, message_obj)
```

### 3. 修改 `_create_and_show_private_chat_window` 和 `_create_and_show_private_chat_window_for_history` 方法

在创建私聊窗口时，使用正确的会话ID：

```python
def _create_and_show_private_chat_window(self, target_user: str, message_obj=None):
    """创建并显示私聊窗口"""
    from client.views.PrivateChatWindow import PrivateChatWindow
    from client.models.vo import ConversationVO
    import uuid
    
    # 检查是否已经存在该私聊窗口
    private_window_key = f"{target_user}_{self.username}"
    if private_window_key in self.controller.private_chat_windows:
        # 窗口已存在，直接显示并添加消息
        private_chat_window = self.controller.private_chat_windows[private_window_key]
        if message_obj:
            # 如果是VO对象，直接添加
            if hasattr(message_obj, 'content_type'):
                private_chat_window.add_private_message(message_obj)
                # 如果消息中包含会话ID，更新窗口的会话ID
                if hasattr(message_obj, 'conversation_id') and message_obj.conversation_id:
                    from client.models.vo import ConversationVO
                    updated_conversation = ConversationVO(
                        conversation_id=message_obj.conversation_id,
                        user1_name=self.username,
                        user2_name=target_user,
                        user1_id="",
                        user2_id=""
                    )
                    private_chat_window.update_conversation(updated_conversation)
            elif isinstance(message_obj, dict):
                # 字典对象，转换为VO
                from client.models.vo import PrivateMessageVO
                private_message_vo = PrivateMessageVO.from_dict(message_obj)
                private_chat_window.add_private_message(private_message_vo)
                # 如果消息中包含会话ID，更新窗口的会话ID
                if message_obj.get('conversation_id'):
                    from client.models.vo import ConversationVO
                    updated_conversation = ConversationVO(
                        conversation_id=message_obj['conversation_id'],
                        user1_name=self.username,
                        user2_name=target_user,
                        user1_id="",
                        user2_id=""
                    )
                    private_chat_window.update_conversation(updated_conversation)
        private_chat_window.bring_to_front()
        return private_chat_window
    
    # 从消息对象中获取会话ID（如果有的话）
    conversation_id = None
    if message_obj:
        if hasattr(message_obj, 'conversation_id'):
            conversation_id = message_obj.conversation_id
        elif isinstance(message_obj, dict):
            conversation_id = message_obj.get('conversation_id')
    
    # 创建会话对象
    conversation = ConversationVO(
        conversation_id=conversation_id if conversation_id else str(uuid.uuid4()),
        user1_name=self.username,
        user2_name=target_user,
        user1_id="",  # 实际应从服务器获取
        user2_id=""   # 实际应从服务器获取
    )
    
    # 创建新的私聊窗口
    private_chat_window = PrivateChatWindow(conversation, self.username, self.controller)
    private_chat_window.send_message.connect(self.on_send_private_message)
    private_chat_window.load_history.connect(self.on_load_private_history)
    private_chat_window.window_closed.connect(self.on_private_window_closed)
    
    # 将窗口添加到控制器
    self.controller.private_chat_windows[private_window_key] = private_chat_window
    
    # 如果有消息，添加到窗口
    if message_obj:
        if hasattr(message_obj, 'content_type'):
            # VO对象
            private_chat_window.add_private_message(message_obj)
        elif isinstance(message_obj, dict):
            # 字典对象，转换为VO
            from client.models.vo import PrivateMessageVO
            private_message_vo = PrivateMessageVO.from_dict(message_obj)
            private_chat_window.add_private_message(private_message_vo)
    
    # 显示私聊窗口
    private_chat_window.show()
    private_chat_window.bring_to_front()
    
    log.info(f"为 {target_user} 创建并显示私聊窗口，会话ID: {conversation.conversation_id}")
    
    return private_chat_window
```

### 4. 修改 `PrivateChatWindow.py` 中的 `show` 方法

确保只有在有会话ID时才加载历史消息：

```python
def show(self):
    """显示窗口"""
    super().show()
    self.is_open = True
    # 只有在有会话ID时才加载历史消息
    if self.conversation.conversation_id:
        self.load_history.emit(self.conversation.conversation_id, 50)
```

### 5. 调试日志

在关键位置添加更多的日志输出，以便调试：

在 `message_manager.py` 的 `get_private_history_messages` 方法中添加日志：

```python
async def get_private_history_messages(self, conversation_id: str, limit: int = 50) -> List[dict]:
    """
    获取私聊历史消息
    """
    try:
        log.debug(f"获取私聊历史消息 - conversation_id: {conversation_id}, limit: {limit}")
        async with PgHelper.get_async_session(self.db_engine) as session:
            # 获取会话的所有消息
            messages = await self.private_message_crud.get_by_conversation_id(
                session, conversation_id, limit=limit
            )
            log.debug(f"找到 {len(messages)} 条私聊历史消息")
            
            # ... 后续代码保持不变 ...
```

## 测试步骤：

1. 应用上述修改后，重启服务器和客户端
2. 进行私聊消息发送
3. 查看服务端日志，确认会话ID是否正确传递
4. 点击私聊窗口的加载历史消息按钮
5. 检查是否能正确加载历史消息

这些修改应该能解决私聊历史消息加载失败的问题。如果问题仍然存在，请检查数据库中的私聊消息表，确认消息是否已正确存储，并且会话ID是否正确。